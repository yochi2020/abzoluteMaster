{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst rate_limiter_1 = require(\"./rate-limiter\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst write_batch_1 = require(\"./write-batch\");\n\nconst validate_1 = require(\"./validate\");\n\nconst logger_1 = require(\"./logger\");\n\nconst google_gax_1 = require(\"google-gax\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nconst MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nexports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\n\nvar BatchState;\n\n(function (BatchState) {\n  BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n  BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n  BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\n  constructor(firestore, maxBatchSize) {\n    super(firestore);\n    this.maxBatchSize = maxBatchSize;\n    /**\n     * The state of the batch.\n     */\n\n    this.state = BatchState.OPEN; // The set of document reference paths present in the WriteBatch.\n\n    this.docPaths = new Set(); // An array of pending write operations. Only contains writes that have not\n    // been resolved.\n\n    this.pendingOps = [];\n  }\n\n  has(documentRef) {\n    return this.docPaths.has(documentRef.path);\n  }\n\n  markReadyToSend() {\n    if (this.state === BatchState.OPEN) {\n      this.state = BatchState.READY_TO_SEND;\n    }\n  }\n\n  isOpen() {\n    return this.state === BatchState.OPEN;\n  }\n\n  isReadyToSend() {\n    return this.state === BatchState.READY_TO_SEND;\n  }\n\n  async bulkCommit() {\n    assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n    this.state = BatchState.SENT; // Capture the error stack to preserve stack tracing across async calls.\n\n    const stack = Error().stack;\n    let results = [];\n\n    try {\n      const retryCodes = util_1.getRetryCodes('batchWrite');\n      const response = await this._commit({\n        retryCodes,\n        methodName: 'batchWrite'\n      });\n      results = response.writeResults.map((result, i) => {\n        const status = response.status[i];\n        const error = new google_gax_1.GoogleError(status.message || undefined);\n        error.code = status.code; // Since delete operations currently do not have write times, use a\n        // sentinel Timestamp value.\n        // TODO(b/158502664): Use actual delete timestamp.\n\n        const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n        const updateTime = error.code === google_gax_1.Status.OK ? timestamp_1.Timestamp.fromProto(result.updateTime || DELETE_TIMESTAMP_SENTINEL) : null;\n        return new write_batch_1.BatchWriteResult(updateTime, error);\n      });\n    } catch (err) {\n      // Map the failure to each individual write's result.\n      results = this.pendingOps.map(() => {\n        return {\n          writeTime: null,\n          status: util_1.wrapError(err, stack)\n        };\n      });\n    }\n\n    return this.processResults(results);\n  }\n  /**\n   * Helper to update data structures associated with the operation and returns\n   * the result.\n   */\n\n\n  processLastOperation(documentRef) {\n    assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n    this.docPaths.add(documentRef.path);\n    assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n    const deferred = new util_1.Deferred();\n    this.pendingOps.push(deferred);\n\n    if (this._opCount === this.maxBatchSize) {\n      this.state = BatchState.READY_TO_SEND;\n    }\n\n    return deferred.promise.then(result => {\n      if (result.writeTime) {\n        return new write_batch_1.WriteResult(result.writeTime);\n      } else {\n        throw result.status;\n      }\n    });\n  }\n  /**\n   * Resolves the individual operations in the batch with the results.\n   */\n\n\n  async processResults(results) {\n    await Promise.all(results.map((result, i) => {\n      const op = this.pendingOps[i];\n\n      if (result.status.code === google_gax_1.Status.OK) {\n        op.resolve(result);\n      } else {\n        op.reject(result.status);\n      }\n\n      return util_1.silencePromise(op.promise);\n    }));\n  }\n\n}\n/**\n * The error thrown when a BulkWriter operation fails.\n *\n * @class BulkWriterError\n */\n\n\nclass BulkWriterError extends Error {\n  /** @hideconstructor */\n  constructor(\n  /** The status code of the error. */\n  code,\n  /** The error message of the error. */\n  message,\n  /** The document reference the operation was performed on. */\n  documentRef,\n  /** The type of operation performed. */\n  operationType,\n  /** How many times this operation has been attempted unsuccessfully. */\n  failedAttempts) {\n    super(message);\n    this.code = code;\n    this.message = message;\n    this.documentRef = documentRef;\n    this.operationType = operationType;\n    this.failedAttempts = failedAttempts;\n  }\n\n}\n\nexports.BulkWriterError = BulkWriterError;\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class BulkWriter\n */\n\nclass BulkWriter {\n  /** @hideconstructor */\n  constructor(firestore, options) {\n    var _a, _b;\n\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     */\n\n    this._maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * A queue of batches to be written.\n     */\n\n    this._batchQueue = [];\n    /**\n     * A queue of batches containing operations that need to be retried.\n     */\n\n    this._retryBatchQueue = [];\n    /**\n     * A list of promises that represent sent batches. Each promise is resolved\n     * when the batch's response is received. This includes batches from both the\n     * batchQueue and retryBatchQueue.\n     */\n\n    this._pendingBatches = new Set();\n    /**\n     * A list of promises that represent pending BulkWriter operations. Each\n     * promise is resolved when the BulkWriter operation resolves. This set\n     * includes retries. Each retry's promise is added, attempted, and removed\n     * from this set before scheduling the next retry.\n     */\n\n    this._pendingOps = new Set();\n    /**\n     * Whether this BulkWriter instance has started to close. Afterwards, no\n     * new operations can be enqueued, except for retry operations scheduled by\n     * the error handler.\n     */\n\n    this._closing = false;\n    /**\n     * The user-provided callback to be run every time a BulkWriter operation\n     * successfully completes.\n     * @private\n     */\n\n    this._successFn = () => {};\n    /**\n     * The user-provided callback to be run every time a BulkWriter operation\n     * fails.\n     * @private\n     */\n\n\n    this._errorFn = error => {\n      const retryCodes = util_1.getRetryCodes('batchWrite');\n      return error.code !== undefined && retryCodes.includes(error.code) && error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS;\n    };\n\n    this.firestore._incrementBulkWritersCount();\n\n    validateBulkWriterOptions(options);\n\n    if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n      this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    } else {\n      let startingRate = exports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND;\n      let maxRate = Number.POSITIVE_INFINITY;\n\n      if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n        if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n          maxRate = options.throttling.maxOpsPerSecond;\n        }\n\n        if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n          startingRate = options.throttling.initialOpsPerSecond;\n        } // The initial validation step ensures that the maxOpsPerSecond is\n        // greater than initialOpsPerSecond. If this inequality is true, that\n        // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n        // than the default starting rate.\n\n\n        if (maxRate < startingRate) {\n          startingRate = maxRate;\n        } // Ensure that the batch size is not larger than the number of allowed\n        // operations per second.\n\n\n        if (startingRate < this._maxBatchSize) {\n          this._maxBatchSize = startingRate;\n        }\n      }\n\n      this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n    }\n  }\n  /**\n   * Create a document with the provided data. This single operation will fail\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. If the write fails, the promise is rejected with a\n   * [BulkWriterError]{@link BulkWriterError}.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .create(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  create(documentRef, data) {\n    this.verifyNotClosed();\n\n    const op = this._executeWrite(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\n   * Delete a document from the database.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the batch if the\n   * document doesn't exist or was last updated at a different time.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the delete. If the delete fails, the promise is rejected with a\n   * [BulkWriterError]{@link BulkWriterError}.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * bulkWriter\n   *  .delete(documentRef)\n   *  .then(result => {\n   *    console.log('Successfully deleted document');\n   *  })\n   *  .catch(err => {\n   *    console.log('Delete failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  delete(documentRef, precondition) {\n    this.verifyNotClosed();\n\n    const op = this._executeWrite(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\n   * Write to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document does not\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n   * the provided data can be merged into the existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {T} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call remain\n   * untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n   * only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. If the write fails, the promise is rejected with a\n   * [BulkWriterError]{@link BulkWriterError}.\n   *\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .set(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  set(documentRef, data, options) {\n    this.verifyNotClosed();\n\n    const op = this._executeWrite(documentRef, 'set', bulkCommitBatch => bulkCommitBatch.set(documentRef, data, options));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\n   * Update fields of the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n   * exist, the update fails and the entire batch will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n   * alternating list of field paths and values to update or a Precondition to\n   * restrict this update\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. If the write fails, the promise is rejected with a\n   * [BulkWriterError]{@link BulkWriterError}.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * bulkWriter\n   *  .update(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    this.verifyNotClosed();\n\n    const op = this._executeWrite(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\n   * Attaches a listener that is run every time a BulkWriter operation\n   * successfully completes.\n   *\n   * @param callback A callback to be called every time a BulkWriter operation\n   * successfully completes.\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter\n   *   .onWriteResult((documentRef, result) => {\n   *     console.log(\n   *       'Successfully executed write on document: ',\n   *       documentRef,\n   *       ' at: ',\n   *       result\n   *     );\n   *   });\n   */\n\n\n  onWriteResult(callback) {\n    this._successFn = callback;\n  }\n  /**\n   * Attaches an error handler listener that is run every time a BulkWriter\n   * operation fails.\n   *\n   * BulkWriter has a default error handler that retries UNAVAILABLE and\n   * ABORTED errors up to a maximum of 10 failed attempts. When an error\n   * handler is specified, the default error handler will be overwritten.\n   *\n   * @param shouldRetryCallback A callback to be called every time a BulkWriter\n   * operation fails. Returning `true` will retry the operation. Returning\n   * `false` will stop the retry loop.\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter\n   *   .onWriteError((error) => {\n   *     if (\n   *       error.code === GrpcStatus.UNAVAILABLE &&\n   *       error.failedAttempts < MAX_RETRY_ATTEMPTS\n   *     ) {\n   *       return true;\n   *     } else {\n   *       console.log('Failed write at document: ', error.documentRef);\n   *       return false;\n   *     }\n   *   });\n   */\n\n\n  onWriteError(shouldRetryCallback) {\n    this._errorFn = shouldRetryCallback;\n  }\n  /**\n   * Commits all writes that have been enqueued up to this point in parallel.\n   *\n   * Returns a Promise that resolves when all currently queued operations have\n   * been committed. The Promise will never be rejected since the results for\n   * each individual operation are conveyed via their individual Promises.\n   *\n   * The Promise resolves immediately if there are no pending writes. Otherwise,\n   * the Promise waits for all previously issued writes, but it does not wait\n   * for writes that were added after the method is called. If you want to wait\n   * for additional writes, call `flush()` again.\n   *\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\n   * up to this point have been committed.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter.create(documentRef, {foo: 'bar'});\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\n   * bulkWriter.delete(documentRef3);\n   * await flush().then(() => {\n   *   console.log('Executed all writes');\n   * });\n   */\n\n\n  flush() {\n    this.verifyNotClosed(); // Copy the pending ops at the time flush() was called.\n\n    return this._flush(Array.from(this._pendingOps));\n  }\n\n  async _flush(pendingOps) {\n    let batchQueue = this._batchQueue;\n    batchQueue.forEach(batch => batch.markReadyToSend()); // Send all scheduled operations on the BatchQueue first.\n\n    this.sendReadyBatches(batchQueue);\n    await Promise.all(this._pendingBatches); // Afterwards, send all accumulated retry operations. Wait until the\n    // retryBatchQueue is cleared. This way, operations scheduled after\n    // flush() will not be sent until the retries are completed.\n\n    batchQueue = this._retryBatchQueue;\n\n    if (batchQueue.length > 0) {\n      batchQueue.forEach(batch => batch.markReadyToSend());\n      this.sendReadyBatches(batchQueue);\n    } // Make sure user promises resolve before flush() resolves.\n\n\n    return util_1.silencePromise(Promise.all(pendingOps));\n  }\n  /**\n   * Commits all enqueued writes and marks the BulkWriter instance as closed.\n   *\n   * After calling `close()`, calling any method wil throw an error. Any\n   * retries scheduled as part of an `onWriteError()` handler will be run\n   * before the `close()` promise resolves.\n   *\n   * Returns a Promise that resolves when there are no more pending writes. The\n   * Promise will never be rejected. Calling this method will send all requests.\n   * The promise resolves immediately if there are no pending writes.\n   *\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\n   * up to this point have been committed.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter.create(documentRef, {foo: 'bar'});\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\n   * bulkWriter.delete(documentRef3);\n   * await close().then(() => {\n   *   console.log('Executed all writes');\n   * });\n   */\n\n\n  close() {\n    this.verifyNotClosed();\n\n    this.firestore._decrementBulkWritersCount();\n\n    const flushPromise = this.flush();\n    this._closing = true;\n    return flushPromise;\n  }\n  /**\n   * Throws an error if the BulkWriter instance has been closed.\n   * @private\n   */\n\n\n  verifyNotClosed() {\n    if (this._closing) {\n      throw new Error('BulkWriter has already been closed.');\n    }\n  }\n  /**\n   * Return the first eligible batch that can hold a write to the provided\n   * reference, or creates one if no eligible batches are found.\n   *\n   * @private\n   */\n\n\n  getEligibleBatch(documentRef, batchQueue) {\n    if (batchQueue.length > 0) {\n      const lastBatch = batchQueue[batchQueue.length - 1];\n\n      if (lastBatch.isOpen() && !lastBatch.has(documentRef)) {\n        return lastBatch;\n      }\n    }\n\n    return this.createNewBatch(batchQueue);\n  }\n  /**\n   * Creates a new batch and adds it to the appropriate batch queue. If there\n   * is already a batch enqueued, sends the batch after a new one is created.\n   *\n   * @private\n   */\n\n\n  createNewBatch(batchQueue) {\n    const newBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n\n    if (batchQueue.length > 0) {\n      batchQueue[batchQueue.length - 1].markReadyToSend();\n      this.sendReadyBatches(batchQueue);\n    }\n\n    batchQueue.push(newBatch);\n    return newBatch;\n  }\n  /**\n   * Attempts to send batches starting from the front of the provided batch\n   * queue until a batch cannot be sent.\n   *\n   * After a batch is complete, try sending batches again.\n   *\n   * @private\n   */\n\n\n  sendReadyBatches(batchQueue) {\n    let index = 0;\n\n    while (index < batchQueue.length && batchQueue[index].isReadyToSend()) {\n      const batch = batchQueue[index]; // Deferred promise that resolves when the current batch or its\n      // scheduling attempt completes.\n\n      const batchCompletedDeferred = new util_1.Deferred();\n\n      this._pendingBatches.add(batchCompletedDeferred.promise); // Send the batch if it is under the rate limit, or schedule another\n      // attempt after the appropriate timeout.\n\n\n      const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n\n      assert(delayMs !== -1, 'Batch size should be under capacity');\n\n      if (delayMs === 0) {\n        this.sendBatch(batch, batchQueue, batchCompletedDeferred);\n      } else {\n        backoff_1.delayExecution(() => {\n          this.sendReadyBatches(batchQueue);\n          batchCompletedDeferred.resolve();\n\n          this._pendingBatches.delete(batchCompletedDeferred.promise);\n        }, delayMs);\n        break;\n      }\n\n      index++;\n    }\n  }\n  /**\n   * Sends the provided batch and processes the results. After the batch is\n   * committed, sends the next group of ready batches.\n   *\n   * @param batchCompletedDeferred A deferred promise that resolves when the\n   * batch has been sent and received.\n   * @private\n   */\n\n\n  sendBatch(batch, batchQueue, batchCompletedDeferred) {\n    const success = this._rateLimiter.tryMakeRequest(batch._opCount);\n\n    assert(success, 'Batch should be under rate limit to be sent.');\n    batch.bulkCommit().then(() => {\n      // Remove the batch from the BatchQueue after it has been processed.\n      const batchIndex = batchQueue.indexOf(batch);\n      assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n      batchQueue.splice(batchIndex, 1);\n\n      if (batchQueue === this._retryBatchQueue) {\n        batchQueue.forEach(batch => batch.markReadyToSend());\n      }\n\n      batchCompletedDeferred.resolve();\n\n      this._pendingBatches.delete(batchCompletedDeferred.promise);\n\n      this.sendReadyBatches(batchQueue);\n    });\n  }\n  /**\n   * Schedules and runs the provided operation.\n   * @private\n   */\n\n\n  async _executeWrite(documentRef, operationType, operationFn) {\n    // A deferred promise that resolves when operationFn completes.\n    const operationCompletedDeferred = new util_1.Deferred();\n\n    this._pendingOps.add(operationCompletedDeferred.promise);\n\n    try {\n      for (let failedAttempts = 0;; ++failedAttempts) {\n        const batchQueue = failedAttempts > 0 ? this._retryBatchQueue : this._batchQueue;\n        const bulkCommitBatch = this.getEligibleBatch(documentRef, batchQueue); // Send ready batches if this is the first attempt. Subsequent retry\n        // batches are scheduled after the initial batch returns.\n\n        if (failedAttempts === 0) {\n          this.sendReadyBatches(batchQueue);\n        }\n\n        try {\n          operationFn(bulkCommitBatch);\n          const operationResult = await bulkCommitBatch.processLastOperation(documentRef);\n\n          this._successFn(documentRef, operationResult);\n\n          return operationResult;\n        } catch (error) {\n          const bulkWriterError = new BulkWriterError(error.code, error.message, documentRef, operationType, failedAttempts);\n\n          const shouldRetry = this._errorFn(bulkWriterError);\n\n          logger_1.logger('BulkWriter.errorFn', null, 'Running error callback on error code:', error.code, ', shouldRetry:', shouldRetry);\n\n          if (!shouldRetry) {\n            throw bulkWriterError;\n          }\n        }\n      }\n    } finally {\n      operationCompletedDeferred.resolve();\n\n      this._pendingOps.delete(operationCompletedDeferred.promise);\n    }\n  }\n  /**\n   * Sets the maximum number of allowed operations in a batch.\n   *\n   * @private\n   */\n  // Visible for testing.\n\n\n  _setMaxBatchSize(size) {\n    this._maxBatchSize = size;\n  }\n  /**\n   * Returns the rate limiter for testing.\n   *\n   * @private\n   */\n  // Visible for testing.\n\n\n  _getRateLimiter() {\n    return this._rateLimiter;\n  }\n\n}\n\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\n\nfunction validateBulkWriterOptions(value) {\n  if (validate_1.validateOptional(value, {\n    optional: true\n  })) {\n    return;\n  }\n\n  const argName = 'options';\n\n  if (!util_1.isObject(value)) {\n    throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\n  }\n\n  const options = value;\n\n  if (options.throttling === undefined || typeof options.throttling === 'boolean') {\n    return;\n  }\n\n  if (options.throttling.initialOpsPerSecond !== undefined) {\n    validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n      minValue: 1\n    });\n  }\n\n  if (options.throttling.maxOpsPerSecond !== undefined) {\n    validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n      minValue: 1\n    });\n\n    if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {\n      throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/chanaphatsuzuki/Desktop/programming/abzolute-master/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","assert","require","backoff_1","rate_limiter_1","timestamp_1","util_1","write_batch_1","validate_1","logger_1","google_gax_1","MAX_BATCH_SIZE","DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","BatchState","BulkCommitBatch","WriteBatch","constructor","firestore","maxBatchSize","state","OPEN","docPaths","Set","pendingOps","has","documentRef","path","markReadyToSend","READY_TO_SEND","isOpen","isReadyToSend","bulkCommit","SENT","stack","Error","results","retryCodes","getRetryCodes","response","_commit","methodName","writeResults","map","result","i","status","error","GoogleError","message","undefined","code","DELETE_TIMESTAMP_SENTINEL","Timestamp","fromMillis","updateTime","Status","OK","fromProto","BatchWriteResult","err","writeTime","wrapError","processResults","processLastOperation","add","deferred","Deferred","push","_opCount","promise","then","WriteResult","Promise","all","op","resolve","reject","silencePromise","BulkWriterError","operationType","failedAttempts","BulkWriter","options","_a","_b","_maxBatchSize","_batchQueue","_retryBatchQueue","_pendingBatches","_pendingOps","_closing","_successFn","_errorFn","includes","MAX_RETRY_ATTEMPTS","_incrementBulkWritersCount","validateBulkWriterOptions","throttling","_rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","startingRate","maxRate","maxOpsPerSecond","initialOpsPerSecond","create","data","verifyNotClosed","_executeWrite","bulkCommitBatch","delete","precondition","set","update","dataOrField","preconditionOrValues","onWriteResult","callback","onWriteError","shouldRetryCallback","flush","_flush","Array","from","batchQueue","forEach","batch","sendReadyBatches","length","close","_decrementBulkWritersCount","flushPromise","getEligibleBatch","lastBatch","createNewBatch","newBatch","index","batchCompletedDeferred","delayMs","getNextRequestDelayMs","sendBatch","delayExecution","success","tryMakeRequest","batchIndex","indexOf","splice","operationFn","operationCompletedDeferred","operationResult","bulkWriterError","shouldRetry","logger","_setMaxBatchSize","size","_getRateLimiter","validateOptional","optional","argName","isObject","invalidArgumentMessage","validateInteger","minValue"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\nconst validate_1 = require(\"./validate\");\nconst logger_1 = require(\"./logger\");\nconst google_gax_1 = require(\"google-gax\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nexports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\nvar BatchState;\n(function (BatchState) {\n    BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n    BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n    BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\n    constructor(firestore, maxBatchSize) {\n        super(firestore);\n        this.maxBatchSize = maxBatchSize;\n        /**\n         * The state of the batch.\n         */\n        this.state = BatchState.OPEN;\n        // The set of document reference paths present in the WriteBatch.\n        this.docPaths = new Set();\n        // An array of pending write operations. Only contains writes that have not\n        // been resolved.\n        this.pendingOps = [];\n    }\n    has(documentRef) {\n        return this.docPaths.has(documentRef.path);\n    }\n    markReadyToSend() {\n        if (this.state === BatchState.OPEN) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n    }\n    isOpen() {\n        return this.state === BatchState.OPEN;\n    }\n    isReadyToSend() {\n        return this.state === BatchState.READY_TO_SEND;\n    }\n    async bulkCommit() {\n        assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n        this.state = BatchState.SENT;\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let results = [];\n        try {\n            const retryCodes = util_1.getRetryCodes('batchWrite');\n            const response = await this._commit({ retryCodes, methodName: 'batchWrite' });\n            results = response.writeResults.map((result, i) => {\n                const status = response.status[i];\n                const error = new google_gax_1.GoogleError(status.message || undefined);\n                error.code = status.code;\n                // Since delete operations currently do not have write times, use a\n                // sentinel Timestamp value.\n                // TODO(b/158502664): Use actual delete timestamp.\n                const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n                const updateTime = error.code === google_gax_1.Status.OK\n                    ? timestamp_1.Timestamp.fromProto(result.updateTime || DELETE_TIMESTAMP_SENTINEL)\n                    : null;\n                return new write_batch_1.BatchWriteResult(updateTime, error);\n            });\n        }\n        catch (err) {\n            // Map the failure to each individual write's result.\n            results = this.pendingOps.map(() => {\n                return {\n                    writeTime: null,\n                    status: util_1.wrapError(err, stack),\n                };\n            });\n        }\n        return this.processResults(results);\n    }\n    /**\n     * Helper to update data structures associated with the operation and returns\n     * the result.\n     */\n    processLastOperation(documentRef) {\n        assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n        this.docPaths.add(documentRef.path);\n        assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n        const deferred = new util_1.Deferred();\n        this.pendingOps.push(deferred);\n        if (this._opCount === this.maxBatchSize) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n        return deferred.promise.then(result => {\n            if (result.writeTime) {\n                return new write_batch_1.WriteResult(result.writeTime);\n            }\n            else {\n                throw result.status;\n            }\n        });\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n    async processResults(results) {\n        await Promise.all(results.map((result, i) => {\n            const op = this.pendingOps[i];\n            if (result.status.code === google_gax_1.Status.OK) {\n                op.resolve(result);\n            }\n            else {\n                op.reject(result.status);\n            }\n            return util_1.silencePromise(op.promise);\n        }));\n    }\n}\n/**\n * The error thrown when a BulkWriter operation fails.\n *\n * @class BulkWriterError\n */\nclass BulkWriterError extends Error {\n    /** @hideconstructor */\n    constructor(\n    /** The status code of the error. */\n    code, \n    /** The error message of the error. */\n    message, \n    /** The document reference the operation was performed on. */\n    documentRef, \n    /** The type of operation performed. */\n    operationType, \n    /** How many times this operation has been attempted unsuccessfully. */\n    failedAttempts) {\n        super(message);\n        this.code = code;\n        this.message = message;\n        this.documentRef = documentRef;\n        this.operationType = operationType;\n        this.failedAttempts = failedAttempts;\n    }\n}\nexports.BulkWriterError = BulkWriterError;\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class BulkWriter\n */\nclass BulkWriter {\n    /** @hideconstructor */\n    constructor(firestore, options) {\n        var _a, _b;\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         */\n        this._maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * A queue of batches to be written.\n         */\n        this._batchQueue = [];\n        /**\n         * A queue of batches containing operations that need to be retried.\n         */\n        this._retryBatchQueue = [];\n        /**\n         * A list of promises that represent sent batches. Each promise is resolved\n         * when the batch's response is received. This includes batches from both the\n         * batchQueue and retryBatchQueue.\n         */\n        this._pendingBatches = new Set();\n        /**\n         * A list of promises that represent pending BulkWriter operations. Each\n         * promise is resolved when the BulkWriter operation resolves. This set\n         * includes retries. Each retry's promise is added, attempted, and removed\n         * from this set before scheduling the next retry.\n         */\n        this._pendingOps = new Set();\n        /**\n         * Whether this BulkWriter instance has started to close. Afterwards, no\n         * new operations can be enqueued, except for retry operations scheduled by\n         * the error handler.\n         */\n        this._closing = false;\n        /**\n         * The user-provided callback to be run every time a BulkWriter operation\n         * successfully completes.\n         * @private\n         */\n        this._successFn = () => { };\n        /**\n         * The user-provided callback to be run every time a BulkWriter operation\n         * fails.\n         * @private\n         */\n        this._errorFn = error => {\n            const retryCodes = util_1.getRetryCodes('batchWrite');\n            return (error.code !== undefined &&\n                retryCodes.includes(error.code) &&\n                error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS);\n        };\n        this.firestore._incrementBulkWritersCount();\n        validateBulkWriterOptions(options);\n        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n        else {\n            let startingRate = exports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND;\n            let maxRate = Number.POSITIVE_INFINITY;\n            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n                    maxRate = options.throttling.maxOpsPerSecond;\n                }\n                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n                    startingRate = options.throttling.initialOpsPerSecond;\n                }\n                // The initial validation step ensures that the maxOpsPerSecond is\n                // greater than initialOpsPerSecond. If this inequality is true, that\n                // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n                // than the default starting rate.\n                if (maxRate < startingRate) {\n                    startingRate = maxRate;\n                }\n                // Ensure that the batch size is not larger than the number of allowed\n                // operations per second.\n                if (startingRate < this._maxBatchSize) {\n                    this._maxBatchSize = startingRate;\n                }\n            }\n            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n        }\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this.verifyNotClosed();\n        const op = this._executeWrite(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the delete. If the delete fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this.verifyNotClosed();\n        const op = this._executeWrite(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this.verifyNotClosed();\n        const op = this._executeWrite(documentRef, 'set', bulkCommitBatch => bulkCommitBatch.set(documentRef, data, options));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.verifyNotClosed();\n        const op = this._executeWrite(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Attaches a listener that is run every time a BulkWriter operation\n     * successfully completes.\n     *\n     * @param callback A callback to be called every time a BulkWriter operation\n     * successfully completes.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteResult((documentRef, result) => {\n     *     console.log(\n     *       'Successfully executed write on document: ',\n     *       documentRef,\n     *       ' at: ',\n     *       result\n     *     );\n     *   });\n     */\n    onWriteResult(callback) {\n        this._successFn = callback;\n    }\n    /**\n     * Attaches an error handler listener that is run every time a BulkWriter\n     * operation fails.\n     *\n     * BulkWriter has a default error handler that retries UNAVAILABLE and\n     * ABORTED errors up to a maximum of 10 failed attempts. When an error\n     * handler is specified, the default error handler will be overwritten.\n     *\n     * @param shouldRetryCallback A callback to be called every time a BulkWriter\n     * operation fails. Returning `true` will retry the operation. Returning\n     * `false` will stop the retry loop.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteError((error) => {\n     *     if (\n     *       error.code === GrpcStatus.UNAVAILABLE &&\n     *       error.failedAttempts < MAX_RETRY_ATTEMPTS\n     *     ) {\n     *       return true;\n     *     } else {\n     *       console.log('Failed write at document: ', error.documentRef);\n     *       return false;\n     *     }\n     *   });\n     */\n    onWriteError(shouldRetryCallback) {\n        this._errorFn = shouldRetryCallback;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    flush() {\n        this.verifyNotClosed();\n        // Copy the pending ops at the time flush() was called.\n        return this._flush(Array.from(this._pendingOps));\n    }\n    async _flush(pendingOps) {\n        let batchQueue = this._batchQueue;\n        batchQueue.forEach(batch => batch.markReadyToSend());\n        // Send all scheduled operations on the BatchQueue first.\n        this.sendReadyBatches(batchQueue);\n        await Promise.all(this._pendingBatches);\n        // Afterwards, send all accumulated retry operations. Wait until the\n        // retryBatchQueue is cleared. This way, operations scheduled after\n        // flush() will not be sent until the retries are completed.\n        batchQueue = this._retryBatchQueue;\n        if (batchQueue.length > 0) {\n            batchQueue.forEach(batch => batch.markReadyToSend());\n            this.sendReadyBatches(batchQueue);\n        }\n        // Make sure user promises resolve before flush() resolves.\n        return util_1.silencePromise(Promise.all(pendingOps));\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error. Any\n     * retries scheduled as part of an `onWriteError()` handler will be run\n     * before the `close()` promise resolves.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        this.verifyNotClosed();\n        this.firestore._decrementBulkWritersCount();\n        const flushPromise = this.flush();\n        this._closing = true;\n        return flushPromise;\n    }\n    /**\n     * Throws an error if the BulkWriter instance has been closed.\n     * @private\n     */\n    verifyNotClosed() {\n        if (this._closing) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n    getEligibleBatch(documentRef, batchQueue) {\n        if (batchQueue.length > 0) {\n            const lastBatch = batchQueue[batchQueue.length - 1];\n            if (lastBatch.isOpen() && !lastBatch.has(documentRef)) {\n                return lastBatch;\n            }\n        }\n        return this.createNewBatch(batchQueue);\n    }\n    /**\n     * Creates a new batch and adds it to the appropriate batch queue. If there\n     * is already a batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n    createNewBatch(batchQueue) {\n        const newBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n        if (batchQueue.length > 0) {\n            batchQueue[batchQueue.length - 1].markReadyToSend();\n            this.sendReadyBatches(batchQueue);\n        }\n        batchQueue.push(newBatch);\n        return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the provided batch\n     * queue until a batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n    sendReadyBatches(batchQueue) {\n        let index = 0;\n        while (index < batchQueue.length && batchQueue[index].isReadyToSend()) {\n            const batch = batchQueue[index];\n            // Deferred promise that resolves when the current batch or its\n            // scheduling attempt completes.\n            const batchCompletedDeferred = new util_1.Deferred();\n            this._pendingBatches.add(batchCompletedDeferred.promise);\n            // Send the batch if it is under the rate limit, or schedule another\n            // attempt after the appropriate timeout.\n            const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n            assert(delayMs !== -1, 'Batch size should be under capacity');\n            if (delayMs === 0) {\n                this.sendBatch(batch, batchQueue, batchCompletedDeferred);\n            }\n            else {\n                backoff_1.delayExecution(() => {\n                    this.sendReadyBatches(batchQueue);\n                    batchCompletedDeferred.resolve();\n                    this._pendingBatches.delete(batchCompletedDeferred.promise);\n                }, delayMs);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @param batchCompletedDeferred A deferred promise that resolves when the\n     * batch has been sent and received.\n     * @private\n     */\n    sendBatch(batch, batchQueue, batchCompletedDeferred) {\n        const success = this._rateLimiter.tryMakeRequest(batch._opCount);\n        assert(success, 'Batch should be under rate limit to be sent.');\n        batch.bulkCommit().then(() => {\n            // Remove the batch from the BatchQueue after it has been processed.\n            const batchIndex = batchQueue.indexOf(batch);\n            assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n            batchQueue.splice(batchIndex, 1);\n            if (batchQueue === this._retryBatchQueue) {\n                batchQueue.forEach(batch => batch.markReadyToSend());\n            }\n            batchCompletedDeferred.resolve();\n            this._pendingBatches.delete(batchCompletedDeferred.promise);\n            this.sendReadyBatches(batchQueue);\n        });\n    }\n    /**\n     * Schedules and runs the provided operation.\n     * @private\n     */\n    async _executeWrite(documentRef, operationType, operationFn) {\n        // A deferred promise that resolves when operationFn completes.\n        const operationCompletedDeferred = new util_1.Deferred();\n        this._pendingOps.add(operationCompletedDeferred.promise);\n        try {\n            for (let failedAttempts = 0;; ++failedAttempts) {\n                const batchQueue = failedAttempts > 0 ? this._retryBatchQueue : this._batchQueue;\n                const bulkCommitBatch = this.getEligibleBatch(documentRef, batchQueue);\n                // Send ready batches if this is the first attempt. Subsequent retry\n                // batches are scheduled after the initial batch returns.\n                if (failedAttempts === 0) {\n                    this.sendReadyBatches(batchQueue);\n                }\n                try {\n                    operationFn(bulkCommitBatch);\n                    const operationResult = await bulkCommitBatch.processLastOperation(documentRef);\n                    this._successFn(documentRef, operationResult);\n                    return operationResult;\n                }\n                catch (error) {\n                    const bulkWriterError = new BulkWriterError(error.code, error.message, documentRef, operationType, failedAttempts);\n                    const shouldRetry = this._errorFn(bulkWriterError);\n                    logger_1.logger('BulkWriter.errorFn', null, 'Running error callback on error code:', error.code, ', shouldRetry:', shouldRetry);\n                    if (!shouldRetry) {\n                        throw bulkWriterError;\n                    }\n                }\n            }\n        }\n        finally {\n            operationCompletedDeferred.resolve();\n            this._pendingOps.delete(operationCompletedDeferred.promise);\n        }\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        this._maxBatchSize = size;\n    }\n    /**\n     * Returns the rate limiter for testing.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _getRateLimiter() {\n        return this._rateLimiter;\n    }\n}\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\nfunction validateBulkWriterOptions(value) {\n    if (validate_1.validateOptional(value, { optional: true })) {\n        return;\n    }\n    const argName = 'options';\n    if (!util_1.isObject(value)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\n    }\n    const options = value;\n    if (options.throttling === undefined ||\n        typeof options.throttling === 'boolean') {\n        return;\n    }\n    if (options.throttling.initialOpsPerSecond !== undefined) {\n        validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n            minValue: 1,\n        });\n    }\n    if (options.throttling.maxOpsPerSecond !== undefined) {\n        validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n            minValue: 1,\n        });\n        if (options.throttling.initialOpsPerSecond !== undefined &&\n            options.throttling.initialOpsPerSecond >\n                options.throttling.maxOpsPerSecond) {\n            throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n        }\n    }\n}\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}